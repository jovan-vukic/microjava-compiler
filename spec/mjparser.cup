/* ---------> Import section <--------- */
package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;      /* Parser will use lexer tokens */
import org.apache.log4j.*;      /* Parser will display errors */
import rs.ac.bg.etf.pp1.ast.*;  /* Parser will perform syntax tree generation according to generated AST classes */

/* ---------> Code section <--------- */
parser code {:
    Logger log = Logger.getLogger(getClass());
    boolean errorDetected;

    /* Code for reporting syntax errors during parsing */
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      /* Reports a fatal error - parser interrupts processing */
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        /* Reports a syntax error - parser continues processing */
        report_error("\nSyntax error", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        /* Reports a syntax error (parser interrupts processing) */
        report_fatal_error("Fatal error: Parsing cannot continue", cur_token);
    }

    public void report_error(String message, Object info) {
        errorDetected = true;

        /* The value 'info' contains the line number of the error (due to '%line') */
        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol)
            msg.append(" at line ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
:}

init with{:
    errorDetected = false;
:}

scan with {:
    /* Requests tokens generated by the lexer and prints them */
    Symbol s = this.getScanner().next_token();

    if (s != null && s.value != null)
        log.info(s.toString() + " " + s.value.toString());
    return s;
:}

/* ---------> Grammar section <--------- */
/* Terminals: Keywords */
terminal PROG, BREAK, CLASS, ELSE, CONST, IF, WHILE;
terminal NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, FOREACH, FINDANY, FINDALL;

/* Terminals: Operators */
terminal PLUS, MINUS, MUL, DIV, MOD, INC, DEC;
terminal IS_EQUAL, NOT_EQUAL, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL;
terminal AND, OR, EQUAL;
terminal SEMI, COLON, COMMA, POINT;
terminal LEFT_PAREN, RIGHT_PAREN, LEFT_SQUARE_BRACKET, RIGHT_SQUARE_BRACKET, LEFT_BRACE, RIGHT_BRACE, ARROW;

/* Terminals: Constants and identifiers */
/* By assigning type now there is no need to use casting later. These terminals do not need names in productions */
terminal Integer INT_CONST;
terminal Character CHAR_CONST;
terminal Boolean BOOL_CONST;
terminal String IDENT;

/* ---------> Non-terminals <--------- */
/* Adding 'Struct' or 'Obj' type adds a field of the same name to the nonterminal class */
nonterminal Program;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName;

nonterminal DeclList, ConstDecl, VarDecl;
nonterminal ConstAssignmentList;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Const;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ConstAssignment;
nonterminal VarDesignatorList, VarDesignator, LastVarDesignator, ArraySquareBrackets;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;

nonterminal MethodDeclList, MethodType, MethodDecl, MethodVarDeclList;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodTypeName;

nonterminal StatementList, Statement, PrintParam, ReturnParam;
nonterminal DesignatorStatement, AssignmentStatement, DesignatorArrayIndex;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator, ArrayIndexPlaceholder;
nonterminal rs.etf.pp1.symboltable.concepts.Struct AssignmentValue;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Expr, Term, Article, Factor;

nonterminal AddOperator, MulOperator, RelOperator;

/* ---------> Grammar <--------- */
Program                     ::= (Program) PROG ProgName:programName DeclList LEFT_BRACE MethodDeclList RIGHT_BRACE;

ProgName                    ::= (ProgName) IDENT:name;

DeclList                    ::= (VarDeclarations) DeclList VarDecl
                                |
                                (ConstDeclarations) DeclList ConstDecl
                                |
                                (NoDeclarations) /* epsilon */
                                ;

/* ---------> 1. Constant declarations */
ConstDecl                   ::= (ConstDecl) CONST Type:constType ConstAssignmentList SEMI;

ConstAssignmentList         ::= (ConstAssignments) ConstAssignmentList COMMA ConstAssignment
                                |
                                (SingleConstAssignment) ConstAssignment
                                ;

ConstAssignment             ::= (ConstAssignment) IDENT:name EQUAL Const:value;

/* ---------> 2. Variable declarations */
VarDecl                     ::= (VarDecl) Type:varType VarDesignatorList;

VarDesignatorList           ::= (VarDesignators) VarDesignator VarDesignatorList
                                |
                                (SingleVarDesignator) LastVarDesignator
                                ;

VarDesignator               ::= (VarDesignatorNoError) IDENT:varName ArraySquareBrackets COMMA
                                |
                                (VarDesignatorError)
                                error COMMA:varComma
                                {: parser.report_error("Error in declaration [recovery to ',']: at line " + varCommaleft, null);  :}
                                ;

LastVarDesignator           ::= (LastVarDesignatorNoError) IDENT:varName ArraySquareBrackets SEMI
                                |
                                (LastVarDesignatorError)
                                error SEMI:varSemi
                                {: parser.report_error("Error in declaration [recovery to ';']: at line " + varSemileft, null);  :}
                                ;

ArraySquareBrackets         ::= (ArrayBrackets) LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET
                                |
                                (NoArrayBrackets) /* epsilon */
                                ;

Type                        ::= (Type) IDENT:typeName;

/* ---------> 3. Method declarations */
MethodDeclList              ::= (MethodDeclarations) MethodDeclList MethodDecl
                                |
                                (NoMethodDecl) /* epsilon */
                                ;

MethodDecl                  ::= (MethodDecl) MethodTypeName LEFT_PAREN /* FormPars */ RIGHT_PAREN MethodVarDeclList LEFT_BRACE StatementList RIGHT_BRACE;

MethodTypeName              ::= (MethodTypeName) MethodType IDENT:name;

MethodType                  ::= (MethodReturnType) Type:type
                                |
                                (MethodReturnTypeVoid) VOID
                                ;

MethodVarDeclList           ::= (MethodVarDeclarations) MethodVarDeclList VarDecl
                                |
                                (NoMethodVarDecl) /* epsilon */
                                ;

/* ---------> 4. Program statement list */
StatementList               ::= (Statements) StatementList Statement
                                |
                                (NoStatement) /* epsilon */
                                ;

Statement                   ::= (StatementDesignator) DesignatorStatement
                                |
                                (StatementPrint) PRINT LEFT_PAREN Expr:e PrintParam RIGHT_PAREN SEMI
                                |
                                (StatementReturn) RETURN ReturnParam SEMI
                                |
                                (StatementRead) READ LEFT_PAREN Designator:d RIGHT_PAREN SEMI
                                |
                                (StatementBlock) LEFT_BRACE StatementList RIGHT_BRACE
                                ;

PrintParam                  ::= (PrintWidth) COMMA INT_CONST:width
                                |
                                (NoParamWidth) /* epsilon */
                                ;

ReturnParam                 ::= (ReturnExpr) Expr:e
                                |
                                (ReturnEmpty) /* epsilon */
                                ;

/* ---------> 5. Designator Statement */
DesignatorStatement         ::= (DesignatorAssignment) AssignmentStatement
                                |
                                (DesignatorInc) Designator:name INC SEMI
                                |
                                (DesignatorDec) Designator:name DEC SEMI
                                ;

AssignmentStatement         ::= (Assignment) Designator:dest EQUAL AssignmentValue SEMI
                                |
                                (AssignmentError)
                                error SEMI:assignSemi
                                {: parser.report_error("Assignment Error [recovery until ';'] : at line " + assignSemileft, null);  :}
                                ;

AssignmentValue             ::= (AssignmentValueExpr) Expr:e
                                |
                                (AssignmentValueFindAny) Designator:array POINT FINDANY LEFT_PAREN Expr:e RIGHT_PAREN
                                |
                                (AssignmentValueFindAll) Designator:array POINT FINDALL LEFT_PAREN Expr:e RIGHT_PAREN
                                ;

Designator                  ::= (Designator) IDENT:name DesignatorArrayIndex:index;

DesignatorArrayIndex        ::= (ArrayIndex) LEFT_SQUARE_BRACKET ArrayIndexPlaceholder Expr:arrayIndex RIGHT_SQUARE_BRACKET
                                |
                                (NoArrayIndex) /* epsilon */
                                ;

ArrayIndexPlaceholder       ::= (ArrayIndexPlaceholder) /* epsilon */ ;

/* ---------> 6. Expr (Expression) */
Expr                        ::= (ExprAddOp) Expr:e AddOperator Term:t
                                |
                                (ExprTermPositive) Term:t
                                |
                                (ExprTermNegative) MINUS Term:t
                                ;

Term                        ::= (TermMulOp) Term:t MulOperator Factor:a
                                |
                                (TermSingleFactor) Factor
                                ;

Factor                      ::= (FactorVar) Designator:varName
                                |
                                (FactorConst) Const:value
                                |
                                (FactorNewArray) NEW Type:arrayType LEFT_SQUARE_BRACKET Expr:arraySize RIGHT_SQUARE_BRACKET
                                |
                                (FactorExpression) LEFT_PAREN Expr:e RIGHT_PAREN
                                ;

Const                       ::= (ConstInt) INT_CONST
                                |
                                (ConstChar) CHAR_CONST
                                |
                                (ConstBool) BOOL_CONST
                                ;

/* ---------> 7. Operators */
AddOperator                 ::= (PlusOp) PLUS
                                |
                                (MinusOp) MINUS
                                ;

MulOperator                 ::= (MulOp) MUL
                                |
                                (DivideOp) DIV
                                |
                                (ModuoOp) MOD
                                ;
